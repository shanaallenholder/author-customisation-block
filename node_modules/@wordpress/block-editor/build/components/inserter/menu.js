"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _clsx = _interopRequireDefault(require("clsx"));
var _element = require("@wordpress/element");
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _compose = require("@wordpress/compose");
var _data = require("@wordpress/data");
var _tips = _interopRequireDefault(require("./tips"));
var _previewPanel = _interopRequireDefault(require("./preview-panel"));
var _blockTypesTab = _interopRequireDefault(require("./block-types-tab"));
var _blockPatternsTab = _interopRequireDefault(require("./block-patterns-tab"));
var _patternCategoryPreviewPanel = require("./block-patterns-tab/pattern-category-preview-panel");
var _mediaTab = require("./media-tab");
var _searchResults = _interopRequireDefault(require("./search-results"));
var _useInsertionPoint = _interopRequireDefault(require("./hooks/use-insertion-point"));
var _tabs = _interopRequireDefault(require("./tabs"));
var _useZoomOut = require("../../hooks/use-zoom-out");
var _store = require("../../store");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const NOOP = () => {};
function InserterMenu({
  rootClientId,
  clientId,
  isAppender,
  __experimentalInsertionIndex,
  onSelect,
  showInserterHelpPanel,
  showMostUsedBlocks,
  __experimentalFilterValue = '',
  shouldFocusBlock = true,
  __experimentalOnPatternCategorySelection = NOOP,
  onClose,
  __experimentalInitialTab,
  __experimentalInitialCategory
}, ref) {
  const isZoomOutMode = (0, _data.useSelect)(select => select(_store.store).__unstableGetEditorMode() === 'zoom-out', []);
  const [filterValue, setFilterValue, delayedFilterValue] = (0, _compose.useDebouncedInput)(__experimentalFilterValue);
  const [hoveredItem, setHoveredItem] = (0, _element.useState)(null);
  const [selectedPatternCategory, setSelectedPatternCategory] = (0, _element.useState)(__experimentalInitialCategory);
  const [patternFilter, setPatternFilter] = (0, _element.useState)('all');
  const [selectedMediaCategory, setSelectedMediaCategory] = (0, _element.useState)(null);
  const [selectedTab, setSelectedTab] = (0, _element.useState)(__experimentalInitialTab);
  const [destinationRootClientId, onInsertBlocks, onToggleInsertionPoint] = (0, _useInsertionPoint.default)({
    rootClientId,
    clientId,
    isAppender,
    insertionIndex: __experimentalInsertionIndex,
    shouldFocusBlock
  });
  const blockTypesTabRef = (0, _element.useRef)();
  const onInsert = (0, _element.useCallback)((blocks, meta, shouldForceFocusBlock) => {
    onInsertBlocks(blocks, meta, shouldForceFocusBlock);
    onSelect();

    // Check for focus loss due to filtering blocks by selected block type
    window.requestAnimationFrame(() => {
      if (!shouldFocusBlock && !blockTypesTabRef?.current.contains(ref.current.ownerDocument.activeElement)) {
        // There has been a focus loss, so focus the first button in the block types tab
        blockTypesTabRef?.current.querySelector('button').focus();
      }
    });
  }, [onInsertBlocks, onSelect, shouldFocusBlock]);
  const onInsertPattern = (0, _element.useCallback)((blocks, patternName) => {
    onInsertBlocks(blocks, {
      patternName
    });
    onSelect();
  }, [onInsertBlocks, onSelect]);
  const onHover = (0, _element.useCallback)(item => {
    onToggleInsertionPoint(!!item);
    setHoveredItem(item);
  }, [onToggleInsertionPoint, setHoveredItem]);
  const onHoverPattern = (0, _element.useCallback)(item => {
    onToggleInsertionPoint(!!item);
  }, [onToggleInsertionPoint]);
  const onClickPatternCategory = (0, _element.useCallback)((patternCategory, filter) => {
    setSelectedPatternCategory(patternCategory);
    setPatternFilter(filter);
    __experimentalOnPatternCategorySelection();
  }, [setSelectedPatternCategory, __experimentalOnPatternCategorySelection]);
  const showPatternPanel = selectedTab === 'patterns' && !delayedFilterValue && !!selectedPatternCategory;
  const showMediaPanel = selectedTab === 'media' && !!selectedMediaCategory;
  const inserterSearch = (0, _element.useMemo)(() => {
    if (selectedTab === 'media') {
      return null;
    }
    return (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components.SearchControl, {
      __nextHasNoMarginBottom: true,
      className: "block-editor-inserter__search",
      onChange: value => {
        if (hoveredItem) {
          setHoveredItem(null);
        }
        setFilterValue(value);
      },
      value: filterValue,
      label: (0, _i18n.__)('Search for blocks and patterns'),
      placeholder: (0, _i18n.__)('Search')
    }), !!delayedFilterValue && (0, _react.createElement)(_searchResults.default, {
      filterValue: delayedFilterValue,
      onSelect: onSelect,
      onHover: onHover,
      onHoverPattern: onHoverPattern,
      rootClientId: rootClientId,
      clientId: clientId,
      isAppender: isAppender,
      __experimentalInsertionIndex: __experimentalInsertionIndex,
      showBlockDirectory: true,
      shouldFocusBlock: shouldFocusBlock,
      prioritizePatterns: selectedTab === 'patterns'
    }));
  }, [selectedTab, hoveredItem, setHoveredItem, setFilterValue, filterValue, delayedFilterValue, onSelect, onHover, onHoverPattern, shouldFocusBlock, clientId, rootClientId, __experimentalInsertionIndex, isAppender]);
  const blocksTab = (0, _element.useMemo)(() => {
    return (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)("div", {
      className: "block-editor-inserter__block-list"
    }, (0, _react.createElement)(_blockTypesTab.default, {
      ref: blockTypesTabRef,
      rootClientId: destinationRootClientId,
      onInsert: onInsert,
      onHover: onHover,
      showMostUsedBlocks: showMostUsedBlocks
    })), showInserterHelpPanel && (0, _react.createElement)("div", {
      className: "block-editor-inserter__tips"
    }, (0, _react.createElement)(_components.VisuallyHidden, {
      as: "h2"
    }, (0, _i18n.__)('A tip for using the block editor')), (0, _react.createElement)(_tips.default, null)));
  }, [destinationRootClientId, onInsert, onHover, showMostUsedBlocks, showInserterHelpPanel]);
  const patternsTab = (0, _element.useMemo)(() => {
    return (0, _react.createElement)(_blockPatternsTab.default, {
      rootClientId: destinationRootClientId,
      onInsert: onInsertPattern,
      onSelectCategory: onClickPatternCategory,
      selectedCategory: selectedPatternCategory
    }, showPatternPanel && (0, _react.createElement)(_patternCategoryPreviewPanel.PatternCategoryPreviewPanel, {
      rootClientId: destinationRootClientId,
      onInsert: onInsertPattern,
      onHover: onHoverPattern,
      category: selectedPatternCategory,
      patternFilter: patternFilter,
      showTitlesAsTooltip: true
    }));
  }, [destinationRootClientId, onHoverPattern, onInsertPattern, onClickPatternCategory, patternFilter, selectedPatternCategory, showPatternPanel]);
  const mediaTab = (0, _element.useMemo)(() => {
    return (0, _react.createElement)(_mediaTab.MediaTab, {
      rootClientId: destinationRootClientId,
      selectedCategory: selectedMediaCategory,
      onSelectCategory: setSelectedMediaCategory,
      onInsert: onInsert
    }, showMediaPanel && (0, _react.createElement)(_mediaTab.MediaCategoryPanel, {
      rootClientId: destinationRootClientId,
      onInsert: onInsert,
      category: selectedMediaCategory
    }));
  }, [destinationRootClientId, onInsert, selectedMediaCategory, setSelectedMediaCategory, showMediaPanel]);

  // When the pattern panel is showing, we want to use zoom out mode
  (0, _useZoomOut.useZoomOut)(showPatternPanel);
  const handleSetSelectedTab = value => {
    // If no longer on patterns tab remove the category setting.
    if (value !== 'patterns') {
      setSelectedPatternCategory(null);
    }
    setSelectedTab(value);
  };

  // Focus first active tab, if any
  const tabsRef = (0, _element.useRef)();
  (0, _element.useLayoutEffect)(() => {
    if (tabsRef.current) {
      window.requestAnimationFrame(() => {
        tabsRef.current.querySelector('[role="tab"][aria-selected="true"]')?.focus();
      });
    }
  }, []);
  return (0, _react.createElement)("div", {
    className: (0, _clsx.default)('block-editor-inserter__menu', {
      'show-panel': showPatternPanel || showMediaPanel,
      'is-zoom-out': isZoomOutMode
    }),
    ref: ref
  }, (0, _react.createElement)("div", {
    className: "block-editor-inserter__main-area"
  }, (0, _react.createElement)(_tabs.default, {
    ref: tabsRef,
    onSelect: handleSetSelectedTab,
    onClose: onClose,
    selectedTab: selectedTab
  }, inserterSearch, selectedTab === 'blocks' && !delayedFilterValue && blocksTab, selectedTab === 'patterns' && !delayedFilterValue && patternsTab, selectedTab === 'media' && mediaTab)), showInserterHelpPanel && hoveredItem && (0, _react.createElement)(_components.Popover, {
    className: "block-editor-inserter__preview-container__popover",
    placement: "right-start",
    offset: 16,
    focusOnMount: false,
    animate: false
  }, (0, _react.createElement)(_previewPanel.default, {
    item: hoveredItem
  })));
}
var _default = exports.default = (0, _element.forwardRef)(InserterMenu);
//# sourceMappingURL=menu.js.map