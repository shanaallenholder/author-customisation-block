"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__unstableUseBlockElement = useBlockElement;
exports.__unstableUseBlockRef = useBlockRef;
exports.useBlockRefProvider = useBlockRefProvider;
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _blockRefsProvider = require("../../provider/block-refs-provider");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('@wordpress/element').RefCallback} RefCallback */
/** @typedef {import('@wordpress/element').RefObject} RefObject */

/**
 * Provides a ref to the BlockRefs context.
 *
 * @param {string} clientId The client ID of the element ref.
 *
 * @return {RefCallback} Ref callback.
 */
function useBlockRefProvider(clientId) {
  const {
    refsMap
  } = (0, _element.useContext)(_blockRefsProvider.BlockRefs);
  return (0, _compose.useRefEffect)(element => {
    refsMap.set(clientId, element);
    return () => refsMap.delete(clientId);
  }, [clientId]);
}

/**
 * Gets a ref pointing to the current block element. Continues to return the same
 * stable ref object even if the `clientId` argument changes. This hook is not
 * reactive, i.e., it won't trigger a rerender of the calling component if the
 * ref value changes. For reactive use cases there is the `useBlockElement` hook.
 *
 * @param {string} clientId The client ID to get a ref for.
 *
 * @return {RefObject} A ref containing the element.
 */
function useBlockRef(clientId) {
  const {
    refsMap
  } = (0, _element.useContext)(_blockRefsProvider.BlockRefs);
  const latestClientId = (0, _element.useRef)();
  latestClientId.current = clientId;

  // Always return an object, even if no ref exists for a given client ID, so
  // that `current` works at a later point.
  return (0, _element.useMemo)(() => ({
    get current() {
      var _refsMap$get;
      return (_refsMap$get = refsMap.get(latestClientId.current)) !== null && _refsMap$get !== void 0 ? _refsMap$get : null;
    }
  }), [refsMap]);
}

/**
 * Return the element for a given client ID. Updates whenever the element
 * changes, becomes available, or disappears.
 *
 * @param {string} clientId The client ID to an element for.
 *
 * @return {Element|null} The block's wrapper element.
 */
function useBlockElement(clientId) {
  var _useObservableValue;
  const {
    refsMap
  } = (0, _element.useContext)(_blockRefsProvider.BlockRefs);
  return (_useObservableValue = (0, _compose.useObservableValue)(refsMap, clientId)) !== null && _useObservableValue !== void 0 ? _useObservableValue : null;
}
//# sourceMappingURL=use-block-refs.js.map