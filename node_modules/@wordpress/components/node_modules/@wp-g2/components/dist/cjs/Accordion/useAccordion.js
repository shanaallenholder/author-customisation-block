"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAccordionState = useAccordionState;
exports.useAccordionProps = useAccordionProps;
exports.useAccordion = useAccordion;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _context = require("@wp-g2/context");

var _utils = require("@wp-g2/utils");

var _lodash = require("lodash");

var _react = require("react");

var _Accordion = require("./Accordion.Context");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @param {any} current
 * @returns {current is any[] | string}
 */
var isCurrentValid = function (current) {
  return Array.isArray(current) || typeof current === 'string';
};
/**
 * @param {string[]} next
 */


var sanitizeState = function (next) {
  return (0, _lodash.uniq)(next.filter(Boolean));
};
/**
 * @param {string[]} prev
 * @param {string | string[]} next
 */


var setCurrentState = function (prev, next) {
  if (prev === void 0) {
    prev = [];
  }

  if (!isCurrentValid(next)) return prev;
  var nextState = Array.isArray(next) ? [].concat(prev, next) : [].concat(prev, [next]);
  return sanitizeState(nextState);
};
/**
 * @typedef State
 * @property {boolean} allowMultiple
 * @property {string[]} current
 */

/**
 * @param {State} initialState
 * @returns {State}
 */


function useInitialState(_ref) {
  var _ref$allowMultiple = _ref.allowMultiple,
      allowMultiple = _ref$allowMultiple === void 0 ? false : _ref$allowMultiple,
      current = _ref.current;
  var initialState = (0, _utils.useSealedState)({
    allowMultiple: allowMultiple,
    current: setCurrentState([], current)
  });
  return initialState;
}
/**
 * @template {(...args: any[]) => any} T
 * @param {T} fn
 * @returns {T}
 */


function useAction(fn) {
  return (0, _react.useCallback)(fn, []);
}
/** @typedef {string | string[]} Payload */

/** @typedef {{ type: 'add', payload: Payload }} AddAction */

/** @typedef {{ type: 'remove', payload: Payload }} RemoveAction */

/** @typedef {{ type: 'set', payload: Payload }} SetAction */

/**
 * @typedef {
	| AddAction
	| RemoveAction
	| SetAction
} Action
 */

/**
 * @param {State} state
 * @param {Action} action
 *
 * @returns {State}
 */


function reducer(state, action) {
  var current = state.current;

  switch (action.type) {
    case 'add':
      {
        var next = action.payload;
        if (!isCurrentValid(next)) return state;
        if (!(0, _utils.simpleEqual)(current, next)) return state;
        return _objectSpread(_objectSpread({}, state), {}, {
          current: setCurrentState(current, next)
        });
      }

    case 'remove':
      {
        var _next = action.payload;
        if (!isCurrentValid(_next)) return state;
        return _objectSpread(_objectSpread({}, state), {}, {
          current: sanitizeState(current.filter(function (id) {
            return id === _next;
          }))
        });
      }

    case 'set':
      {
        var _next2 = action.payload;
        if (!isCurrentValid(_next2)) return state;
        if ((0, _utils.simpleEqual)(current, _next2)) return state;
        var nextState = Array.isArray(_next2) ? [_next2[0]] : [_next2];
        return _objectSpread(_objectSpread({}, state), {}, {
          current: sanitizeState(nextState)
        });
      }

    default:
      {
        return state;
      }
  }
}
/**
 * @typedef {State & { onChange: (current: State['current']) => void }} OwnProps
 */

/**
 * @param {OwnProps} props
 * @returns {import('./Accordion.Context').AccordionContext}
 */


function useAccordionState(props) {
  var _useContextSystem = (0, _context.useContextSystem)(props, 'Accordion'),
      _useContextSystem$onC = _useContextSystem.onChange,
      onChange = _useContextSystem$onC === void 0 ? _lodash.noop : _useContextSystem$onC,
      otherProps = (0, _objectWithoutProperties2.default)(_useContextSystem, ["onChange"]);

  var initialState = useInitialState(otherProps);

  var _useReducer = (0, _react.useReducer)(reducer, initialState),
      _useReducer2 = (0, _slicedToArray2.default)(_useReducer, 2),
      _useReducer2$ = _useReducer2[0],
      allowMultiple = _useReducer2$.allowMultiple,
      current = _useReducer2$.current,
      dispatch = _useReducer2[1]; // Actions


  var add = useAction(function (
  /** @type {Payload} */
  next) {
    dispatch({
      type: 'add',
      payload: next
    });
  });
  var remove = useAction(function (
  /** @type {Payload} */
  next) {
    dispatch({
      type: 'remove',
      payload: next
    });
  });
  var set = useAction(function (
  /** @type {Payload} */
  next) {
    if (allowMultiple) return add(next);
    dispatch({
      type: 'set',
      payload: next
    });
  }); // Selectors

  // Synchronize props + state
  (0, _utils.useUpdateEffect)(function () {
    set(props.current);
  }, [set, props.current]);
  (0, _utils.useUpdateEffect)(function () {
    onChange(current);
  }, [current, onChange]);
  return {
    allowMultiple: allowMultiple,
    current: current,
    getIsVisible: function getIsVisible(
    /** @type {string} */
    id) {
      return !!id && (current == null ? void 0 : current.includes(id));
    },
    add: add,
    remove: remove,
    set: set
  };
}
/**
 * @typedef Props
 * @property {boolean} [allowMultiple=false]
 * @property {(current: string[] | null) => void} [onChange]
 * @property {string[]} [current]
 * @property {import('react').ReactNode} [children]
 */

/**
 * @param {Props} props
 */


function useAccordionProps(props) {
  var children = props.children,
      otherProps = (0, _objectWithoutProperties2.default)(props, ["children"]);
  var accordionState = useAccordionState(otherProps);
  var contextValue = (0, _react.useMemo)(function () {
    return accordionState;
  }, [accordionState]);
  return _objectSpread({
    children: children,
    contextValue: contextValue
  }, otherProps);
}
/**
 * @param {object} props
 * @param {string} props.id
 * @param {boolean} props.visible
 * @return {[boolean, (id: string) => boolean ]}
 */


function useAccordion(_ref2) {
  var id = _ref2.id,
      visibleProp = _ref2.visible;

  var _useAccordionContext = (0, _Accordion.useAccordionContext)(),
      add = _useAccordionContext.add,
      allowMultiple = _useAccordionContext.allowMultiple,
      getIsVisible = _useAccordionContext.getIsVisible,
      remove = _useAccordionContext.remove,
      set = _useAccordionContext.set;

  var visible = getIsVisible(id);
  var setVisible = (0, _react.useCallback)(function (
  /** @type {boolean} */
  nextVisible) {
    if (!id) return;

    if (nextVisible) {
      if (allowMultiple) {
        add(id);
      } else {
        set(id);
      }
    } else {
      if (allowMultiple) {
        remove(id);
      }
    }
  }, [add, allowMultiple, remove, set, id]);
  (0, _utils.useUpdateEffect)(function () {
    setVisible(visibleProp);
  }, [visibleProp]);
  return [visible, setVisible];
}